#!/bin/bash
# mkinitcpio - modular tool for building an initramfs images
shopt -s extglob
declare -r version=%VERSION%

# globals within mkinitcpio, but not intended to be used by hooks.
_f_functions=/usr/lib/mkinitcpio/functions
_d_config=/etc/mkinitcpio:/usr/lib/mkinitcpio
_d_firmware=(/usr/lib/firmware{,/updates})

declare _d_install
declare _optrootfs _optmoduleroot _optgenimg _optcompress _opthookhelp
declare -a _hooks _opthooks _optskiphooks _optaddhooks _fwerrors
declare -a _ag_opts _comp_opts _add_modules _optkmods
declare -A _runhooks _addedmodules _modpaths _autodetect_cache _built_hooks _addmodule
declare -i _optshowautomods _optsavetree _optshowmods _optarchive
declare -i _optforce _optquiet _optdebug _optcolor _opthooklist _optnogen
declare -i _optstdout=1

_devel=1
if (( _devel )); then
	_d_config="$PWD"; _f_functions="$(realpath $PWD/functions)"
fi

export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
export RPATH="$PATH"

# GREP_OPTIONS="--color=always" will break everything
# CDPATH can affect cd and pushd
# LIBMOUNT_* options can affect findmnt and other tools
unset GREP_OPTIONS CDPATH "${!LIBMOUNT_@}"

# globals within mkinitcpio, intended to be used by hooks.
declare -i systemd fs_autodetect_failed=1
declare -a fstypes

# config
declare -a ARCHIVEGEN_OPTIONS HOOKS COMPRESSION MODULES BINARIES FILES

usage() { cat <<!
mkinitcpio [OPTIONS...] [FILES...]
Modular tool for building an initramfs images.

STDIN and FILES are forwarded to archivegen.
HOOKS and MODULES are comma separated.

Options:
  -h --help              Show this help text
  -V --version           Show package version
  -a --archive           Show image archive
  -v --verbose           Show verbose output
  -d --debug             Show debug output
  -N --nogen             Only run build hooks
  -p --path PATH         Use PATH as config search path, PATH+ to prepend
  -g --write FILE        Write image to FILE
  -f --force             Ignore existing files
  -c --config FILE       Use config FILE
  -o --hooks HOOKS       Only run HOOKS
  -A --addhooks HOOKS    Append HOOKS
  -S --skiphooks HOOKS   Omit running HOOKS
  -H --hookhelp HOOK     Show help for HOOK
  -L --listhooks         Show all hooks
  -n --nocolor           Disable colorized output messages
  -M --automods          Show modules found by autodetect
  -r --moduleroot DIR    Use DIR as filesystem root for /lib/modules
  -R --rootfs DIR        Use alternate system root
  -s --save              Save the build directory
  -z --compress PROGRAM  Compress image with PROGRAM
  -k --kernel VERSION    Use kernel VERSION
  -K --kmod MODULES      Append kernel MODULES
  -X KEY=VALUE           Variable used by archivegen
!
}

version() { cat <<!
mkinitcpio: $version
archivegen: $(archivegen -version)
!
}

cleanup() {
	local err=${1:-$?}

	if ! [[ $_d_workdir ]]; then
		exit "$err"
	fi

	if (( _optsavetree )); then
		printf '%s\n' "${!_autodetect_cache[@]}" > "$_d_workdir/autodetect_modules"
		msgq "%s" "$_d_workdir"
	else
		rm -rf "$_d_workdir"
	fi

	exit "$err"
}

resolve_kernver() {
	local kernel=$1 arch

	if [[ -z $kernel ]]; then
		uname -r
		return 0
	fi

	if [[ ${kernel:0:1} != / ]]; then
		echo "$kernel"
		return 0
	fi

	if [[ ! -e $kernel ]]; then
		error "no such file: %s" "$kernel"
		return 1
	fi

	kver "$kernel" && return
	error "failed to resolve kernel version: %s" "$1"
	return 1
}

hook_help() {
	local resolved script hook=$1

	if ! script=$(find_script $hook); then
		error 'no such hook: %s' "$hook"
		return 1
	fi

	[[ -d "$script" ]] && script+=/build

	# this will be true for broken symlinks as well
	if [[ -z $script ]]; then
		error "no such hook: %s" "$hook"
		return 1
	fi


	# deprecated hooks are symlinks to the replacement
	resolved=$(realpath "$script")
	if [[ "$script" != "$resolved" ]]; then
		warning "'%s' hook has been deprecated by '%s'" "$hook" "${resolved##*/}"
		script=$resolved
	fi

	source "$script"
	if ! declare -f help >/dev/null; then
		error 'missing help function: %s' "$hook"
		return 1
	fi

	help
	unset help
}

hook_list() {
	local resolved
	local -a paths hooklist depr

	IFS=: read -ra paths <<< "$_d_install"

	for path in "${paths[@]}"; do
		for hook in "$path"/*; do
			[[ -e $hook || -L $hook ]] || continue

			# handle deprecated hooks and point to replacement
			if resolved=$(realpath "$hook") && [[ ${hook##*/} != "${resolved##*/}" ]]; then
				resolved=${resolved##*/}
				if ! index_of "$resolved" "${depr[@]}"; then
					# deprecated hook
					depr+=("${hook##*/}")
				fi
				continue
			fi

			msgul "${hook##*/}"
			hook_help "${hook##*/}" | awk '{print "  ", $0} END{print ""}'
		done
	done

	(( ! ${#depr[*]} )) && return

	msgul '\nDEPRECATED'
	printf '%s\n' "${depr[@]}" | sort -u | column -c"${COLUMNS:-$(tput cols)}"
}

compute_hookset() {
	local -a hooks
	local h

	if (( $# )); then
		hooks=("$@")
	else
		hooks=("${HOOKS[@]}" "${_optaddhooks[@]}")
	fi

	(( ${#hooks[@]} )) || return 1

	for h in "${hooks[@]}"; do
		in_array "$h" "${_optskiphooks[@]}" && continue

		case $h in
		autodetect)
			_hooks=($h "${_hooks[@]}")
			continue
			;;
		systemd)
			systemd=1
			;;
		esac

		_hooks+=("$h")
	done

	HOOKS=()
}

source "$_f_functions"

trap 'cleanup 130' INT
trap 'cleanup 143' TERM

_opt_short=A:aMz:c:dfhH:o:k:K:Lr:nNp:R:sS:vVg:X:
_opt_long=(
	add: addhooks:
	archive
	automods
	compress:
	config:
	debug
	force
	help
	hookhelp:
	hooks:
	kernel:
	kmod:
	listhooks
	moduleroot:
	nocolor
	nogen
	path:
	rootfs:
	save
	skiphooks:
	verbose
	version
	write:
)

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

while :; do
	case $1 in
	-a|--archive)
		_optarchive=1
		;;
	-f|--force)
		_optforce=1
		;;
	-R|--rootfs)
		shift
		_optrootfs="$1"
		[[ -d "$_optrootfs" ]] || \
			die 'no such directory: %s' "$_optrootfs"
		RPATH=$_optrootfs${PATH//:/:$_optrootfs}
		;;
	-o|--hooks)
		shift
		IFS=, read -r -a _opthooks <<< "$1"
		;;
	# --add remains for backwards compat
	-A|--add|--addhooks)
		shift
		IFS=, read -r -a add <<< "$1"
		_optaddhooks+=("${add[@]}")
		unset add
		;;
	-c|--config)
		shift
		_f_config=$1
		;;
	-k|--kernel)
		shift
		KERNELVERSION=$1
		;;
	-K|--kmod)
		shift
		IFS=, read -r -a add <<< "$1"
		_optkmods+=("${add[@]}")
		unset add
		;;
	-s|--save)
		_optsavetree=1
		;;
	-g|--write)
		shift
		_optstdout=0
		_optgenimg="$1"
		[[ -d "$1" ]] && die 'path is a directory'
		;;
	-h|--help)
		usage
		cleanup 0
		;;
	-V|--version)
		version
		cleanup 0
		;;
	-n|--nocolor)
		_optcolor=1
		;;
	-N|--nogen)
		_optnogen=1
		;;
	-v|--verbose)
		_optquiet=1
		;;
	-d|--debug)
		_optquiet=1
		_optdebug=1
		;;
	-S|--skiphooks)
		shift
		IFS=, read -r -a skip <<< "$1"
		_optskiphooks+=("${skip[@]}")
		unset skip
		;;
	-H|--hookhelp)
		shift
		_opthookhelp="$1"
		;;
	-L|--listhooks)
		_opthooklist=1
		;;
	-M|--automods)
		_optshowautomods=1
		;;
	-z|--compress)
		shift
		_optcompress=$1
		;;
	-r|--moduleroot)
		shift
		_optmoduleroot=$1
		;;
	-p|--path)
		shift
		case $1 in
		*+) _d_config=$(realpath ${1%%+}):$_d_config ;;
		*) _d_config=$(realpath $1) ;;
		esac
		;;
	-X)
		shift
		_ag_opts+=(-X "$1")
		;;
	--)
		shift
		break 2
		;;
	esac
	shift
done

_d_install=${_d_config//://install:}/install

if [[ -t 1 ]] && (( ! _optcolor )); then
	try_enable_color
fi

if [[ $_opthookhelp ]]; then
	hook_help "$_opthookhelp"
	exit 0
fi

if (( _opthooklist )); then
	hook_list
	exit 0
fi

# insist that /proc and /dev be mounted (important for chroots)
# NOTE: avoid using mountpoint for this -- look for the paths that we actually
# use in mkinitcpio. Avoids issues like FS#26344.
[[ -e /proc/self/mountinfo ]] || die "/proc must be mounted!"
[[ -e /dev/fd ]] || die "/dev must be mounted!"

if [[ $KERNELVERSION != 'none' ]]; then
	KERNELVERSION=$(resolve_kernver "$KERNELVERSION") || cleanup 1
	_d_kmoduledir=$_optmoduleroot/lib/modules/$KERNELVERSION

	[[ -d $_d_kmoduledir ]] || \
		die "no such directory: $_d_kmoduledir"
fi

_d_workdir=$(mktemp -d --tmpdir mkinitcpio.XXXXXX) || cleanup 1
BUILDROOT="$_d_workdir/root"
BUILDARCHIVE="$_d_workdir/archive"

_f_config="${_f_config:-$(PATH=$_d_config type -P config)}"
[[ -f "$_f_config" ]] || die "missing config file %s" "${_f_config:-in $_d_config}"

source "$_f_config" || cleanup 1

# after returning, hooks are populated into the array '_hooks'
# HOOKS should not be referenced from here on
if ! compute_hookset "${_opthooks[@]}"; then
	die 'no hooks'
fi

if (( _optshowautomods )); then
	PATH=$_d_install source 'autodetect'
	build
	printf '%s\n' "${!_autodetect_cache[@]}" | sort
	cleanup 0
fi

# do not overwrite existing files without force
if (( ! _optstdout )) && [[ -f $_optgenimg ]]; then
	(( _optforce )) || die 'file exists, use --force'
fi

if (( ! _optstdout )); then
	if [[ $_optcompress ]]; then
		COMPRESSION=("$_optcompress")
	elif (( ! ${#COMPRESSION[@]} )); then
		COMPRESSION=(pigz gzip lz4 xz)
	fi

	if ! read -r _optcompress < <(
		type -P "${COMPRESSION[@]}"
	); then
		die 'unable to find compressor: %s' "${COMPRESSION[*]}"
	fi

	case ${_optcompress##*/} in
	pigz|gzip)
		_comp_opts=('-n') ;;
	lz4)
		_comp_opts=('-l') ;;
	xz)
		_comp_opts=('--check=crc32') ;;
	esac

	COMPRESSION=("$_optcompress")
fi

msg "$KERNELVERSION${_optcompress:+, $_optcompress ${_comp_opts[*]}}${_optrootfs:+, sysroot:$_optrootfs}"

# prime the _addedmodules list with the builtins for this kernel
if [[ -r $_d_kmoduledir/modules.builtin ]]; then
	while IFS=/ read -a path; do
		modname=${path[-1]%.ko}
		_addedmodules["${modname//-/_}"]=2
	done <"$_d_kmoduledir/modules.builtin"
	unset modname path
fi

if [[ -r $_d_kmoduledir/modules.builtin.modinfo ]]; then
	add_builtin_modinfo < "$_d_kmoduledir/modules.builtin.modinfo"
fi

# set functrace and trap to catch errors in add_* functions
declare -i _builderrors=0
set -o functrace
trap '(( $? )) && [[ $FUNCNAME = add_* ]] && (( ++_builderrors ))' RETURN

add 'mr - ^usr/sbin/ usr/bin/'
for hook in "${_hooks[@]}"; do
	if run_build_hook "$hook"; then
		continue
	fi
	(( _builderrors++ ))
	case $hook in autodetect) break ;; esac
done

add_module "${_optkmods[@]}"

load_config

_add_module "${_add_modules[@]}" || cleanup 1

(( ${#_fwerrors[@]} )) && warning 'missing firmware: %s' "${_fwerrors[*]}"
(( _builderrors )) && cleanup 1

trap -- RETURN
set +o functrace

install_modules "${!_modpaths[@]}"

_ag_opts+=(-elf.{expand,fallback,once} -fmt cpio)

[[ $_optrootfs ]] && _ag_opts+=(-rootfs "$_optrootfs")
(( _optarchive )) && _ag_opts+=(-print)

(( _optnogen )) && cleanup 0

set -o pipefail

if (( _optstdout )); then
	archivegen "${_ag_opts[@]}" "${ARCHIVEGEN_OPTIONS[@]}" "$BUILDARCHIVE" "$@"
else
	archivegen "${_ag_opts[@]}" "${ARCHIVEGEN_OPTIONS[@]}" "$BUILDARCHIVE" "$@" \
		| "$_optcompress" "${_comp_opts[@]}" > "$_optgenimg"
	(( ! $? )) || error "image generation failed"
fi

cleanup $?
