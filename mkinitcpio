#!/bin/bash
# mkinitcpio - modular tool for building an initramfs images
shopt -s extglob
declare -r version=%VERSION%

# globals within mkinitcpio, but not intended to be used by hooks.
_f_functions=/usr/lib/mkinitcpio/functions
_d_config=/etc/mkinitcpio:/usr/lib/mkinitcpio
_d_firmware=(/usr/lib/firmware{,/updates})

declare _d_install
declare _optrootfs _optmoduleroot _optgenimg _optcompress _opthookhelp
declare -a _hooks _opthooks _optskiphooks _optaddhooks _optvars _fwerrors
declare -A _runhooks _addedmodules _modpaths _autodetect_cache
declare -i _optshowautomods _optsavetree _optshowmods _optarchive
declare -i _optforce _optquiet _optdebug _optcolor _opthooklist _optnogen
declare -i _optstdout=1

_devel=1
if (( _devel )); then
	_d_config="$PWD"; _f_functions="$(realpath $PWD/functions)"
fi

export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
export RPATH="$PATH"

# GREP_OPTIONS="--color=always" will break everything
# CDPATH can affect cd and pushd
# LIBMOUNT_* options can affect findmnt and other tools
unset GREP_OPTIONS CDPATH "${!LIBMOUNT_@}"

# globals within mkinitcpio, intended to be used by hooks.
declare -i systemd fs_autodetect_failed=1
declare -a fstypes

usage() { cat <<!
mkinitcpio [OPTIONS...] [FILES...]
Modular tool for building an initramfs images.

STDIN and FILES are forwarded to archivegen, HOOKS are comma separated.

Options:
  -h --help              Show this help text
  -V --version           Show package version
  -a --archive           Show image archive
  -v --verbose           Show verbose output
  -d --debug             Show debug output
  -N --nogen             Only run build hooks
  -p --path PATH         Use PATH as config search path, PATH+ to prepend
  -g --write FILE        Write image to FILE
  -f --force             Ignore existing files
  -c --config FILE       Use config FILE
  -o --hooks HOOKS       Only run HOOKS
  -A --addhooks HOOKS    Append HOOKS
  -S --skiphooks HOOKS   Omit running HOOKS
  -H --hookhelp HOOK     Show help for HOOK
  -L --listhooks         Show all hooks
  -n --nocolor           Disable colorized output messages
  -M --automods          Show modules found by autodetect
  -r --moduleroot DIR    Use DIR as filesystem root for /lib/modules
  -R --rootfs DIR        Use alternate system root
  -s --save              Save the build directory
  -z --compress PROGRAM  Compress image with PROGRAM
  -k --kernel VERSION    Use kernel VERSION
  -X KEY=VALUE           Variable used by archivegen
!
}

version() { cat <<!
mkinitcpio: $version
archivegen: $(archivegen -version)
!
}

cleanup() {
	local err=${1:-$?}

	if ! [[ $_d_workdir ]]; then
		exit "$err"
	fi

	if (( _optsavetree )); then
		printf '%s\n' "${!_autodetect_cache[@]}" > "$_d_workdir/autodetect_modules"
		msgq "%s" "$_d_workdir"
	else
		rm -rf "$_d_workdir"
	fi

	exit "$err"
}

resolve_kernver() {
	local kernel=$1 arch

	if [[ -z $kernel ]]; then
		uname -r
		return 0
	fi

	if [[ ${kernel:0:1} != / ]]; then
		echo "$kernel"
		return 0
	fi

	if [[ ! -e $kernel ]]; then
		error "no such file: %s" "$kernel"
		return 1
	fi

	kver "$kernel" && return
	error "failed to resolve kernel version: %s" "$1"
	return 1
}

hook_help() {
	local resolved script hook=$1

	if ! script=$(find_script $hook); then
		error 'no such hook: %s' "$hook"
		return 1
	fi

	[[ -d "$script" ]] && script+=/build

	# this will be true for broken symlinks as well
	if [[ -z $script ]]; then
		error "no such hook: %s" "$hook"
		return 1
	fi


	# deprecated hooks are symlinks to the replacement
	resolved=$(realpath "$script")
	if [[ "$script" != "$resolved" ]]; then
		warning "'%s' hook has been deprecated by '%s'" "$hook" "${resolved##*/}"
		script=$resolved
	fi

	source "$script"
	if ! declare -f help >/dev/null; then
		error 'missing help function: %s' "$hook"
		return 1
	fi

	help
	unset help
}

hook_list() {
	local resolved
	local -a paths hooklist depr

	IFS=: read -ra paths <<< "$_d_install"

	for path in "${paths[@]}"; do
		for hook in "$path"/*; do
			[[ -e $hook || -L $hook ]] || continue

			# handle deprecated hooks and point to replacement
			if resolved=$(realpath "$hook") && [[ ${hook##*/} != "${resolved##*/}" ]]; then
				resolved=${resolved##*/}
				if ! index_of "$resolved" "${depr[@]}"; then
					# deprecated hook
					depr+=(${hook##*/})
				fi
				continue
			fi

			msgul "${hook##*/}"
			hook_help "${hook##*/}" | awk '{print "  ", $0} END{print ""}'
		done
	done

	(( ! ${#depr[*]} )) && return

	msgul '\nDEPRECATED'
	printf '%s\n' "${depr[@]}" | sort -u | column -c"${COLUMNS:-$(tput cols)}"
}

compute_hookset() {
	for h in "${HOOKS[@]}" "${_optaddhooks[@]}"; do
		in_array "$h" "${_optskiphooks[@]}" && continue
		_hooks+=("$h")
	done
}

build_image() {
	local out=$1; shift
	local compress=$1; shift
	local errmsg error

	case $compress in
	cat)
		unset COMPRESSION_OPTIONS
		;;
	xz)
		COMPRESSION_OPTIONS+=('--check=crc32')
		;;
	lz4)
		COMPRESSION_OPTIONS+=('-l')
		;;
	gzip|pigz)
		COMPRESSION_OPTIONS+=('-n')
		;;
	esac

	if (( _optstdout )); then
		archivegen -rootfs "$_optrootfs" -fmt cpio -elf.{expand,fallback} \
			"${ARCHIVEGEN_OPTIONS[@]}" "$BUILDARCHIVE" "$@"
	else
		archivegen -rootfs "$_optrootfs" -fmt cpio -elf.{expand,fallback} \
			"${ARCHIVEGEN_OPTIONS[@]}" "$BUILDARCHIVE" "$@" | \
			$compress "${COMPRESSION_OPTIONS[@]}" > "$out"

		error=$(( ${PIPESTATUS[1]} ))
	fi

	if (( _builderrors )); then
		warning "errors were encountered during the build. The image may not be complete."
	fi

	if (( error )); then
		error "image generation failed"
	fi
}

source "$_f_functions"

trap 'cleanup 130' INT
trap 'cleanup 143' TERM

_opt_short=A:aMz:c:dfhH:o:k:Lr:nNp:R:sS:vVg:X:
_opt_long=(
	add: addhooks:
	archive
	automods
	compress:
	config:
	debug
	force
	help
	hookhelp:
	hooks:
	kernel:
	listhooks
	moduleroot:
	nocolor
	nogen
	path:
	rootfs:
	save
	skiphooks:
	verbose
	version
	write:
)

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

while :; do
	case $1 in
	-a|--archive)
		_optarchive=1
		;;
	-f|--force)
		_optforce=1
		;;
	-R|--rootfs)
		shift
		_optrootfs="$1"
		RPATH=$_optrootfs${PATH//:/:$_optrootfs}
		;;
	-o|--hooks)
		shift
		IFS=, read -r -a _opthooks <<< "$1"
		;;
	# --add remains for backwards compat
	-A|--add|--addhooks)
		shift
		IFS=, read -r -a add <<< "$1"
		_optaddhooks+=("${add[@]}")
		unset add
		;;
	-c|--config)
		shift
		_f_config=$1
		;;
	-k|--kernel)
		shift
		KERNELVERSION=$1
		;;
	-s|--save)
		_optsavetree=1
		;;
	-g|--write)
		shift
		_optstdout=0
		_optgenimg="$1"
		[[ -d "$1" ]] && die 'path is a directory'
		;;
	-h|--help)
		usage
		cleanup 0
		;;
	-V|--version)
		version
		cleanup 0
		;;
	-n|--nocolor)
		_optcolor=1
		;;
	-N|--nogen)
		_optnogen=1
		;;
	-v|--verbose)
		_optquiet=1
		;;
	-d|--debug)
		_optquiet=1
		_optdebug=1
		;;
	-S|--skiphooks)
		shift
		IFS=, read -r -a skip <<< "$1"
		_optskiphooks+=("${skip[@]}")
		unset skip
		;;
	-H|--hookhelp)
		shift
		_opthookhelp="$1"
		;;
	-L|--listhooks)
		_opthooklist=1
		;;
	-M|--automods)
		_optshowautomods=1
		;;
	-z|--compress)
		shift
		_optcompress=$1
		;;
	-r|--moduleroot)
		shift
		_optmoduleroot=$1
		;;
	-p|--path)
		shift
		case $1 in
		*+) _d_config=$(realpath ${1%%+}):$_d_config ;;
		*) _d_config=$(realpath $1) ;;
		esac
		;;
	-X)
		shift
		_optvars+=(-X "$1")
		;;
	--)
		shift
		break 2
		;;
	esac
	shift
done

_d_install=${_d_config//://install:}/install

if [[ -t 1 ]] && (( ! _optcolor )); then
	try_enable_color
fi

if [[ $_opthookhelp ]]; then
	hook_help "$_opthookhelp"
	exit 0
fi

if (( _opthooklist )); then
	hook_list
	exit 0
fi

# insist that /proc and /dev be mounted (important for chroots)
# NOTE: avoid using mountpoint for this -- look for the paths that we actually
# use in mkinitcpio. Avoids issues like FS#26344.
[[ -e /proc/self/mountinfo ]] || die "/proc must be mounted!"
[[ -e /dev/fd ]] || die "/dev must be mounted!"

if [[ $KERNELVERSION != 'none' ]]; then
	KERNELVERSION=$(resolve_kernver "$KERNELVERSION") || cleanup 1
	_d_kmoduledir=$_optmoduleroot/lib/modules/$KERNELVERSION

	[[ -d $_d_kmoduledir ]] || \
		die "no such directory: $_d_kmoduledir"
fi

_d_workdir=$(mktemp -d --tmpdir mkinitcpio.XXXXXX) || cleanup 1
BUILDROOT="$_d_workdir/root"
BUILDARCHIVE="$_d_workdir/archive"

_f_config="${_f_config:-$(PATH=$_d_config type -P config)}"
[[ -f "$_f_config" ]] || die "missing config file %s" "${_f_config:-in $_d_config}"

source "$_f_config" || cleanup 1

arrayize_config

# after returning, hooks are populated into the array '_hooks'
# HOOKS should not be referenced from here on
compute_hookset

(( ${#_opthooks[@]} )) && _hooks=(${_opthooks[@]})
(( ${#_hooks[*]} )) || die 'no hooks'

in_array systemd "${_hooks[@]}" && systemd=1

if (( _optshowautomods )); then
	PATH=$_d_install source 'autodetect'
	build
	printf '%s\n' "${!_autodetect_cache[@]}" | sort
	cleanup 0
fi

# do not overwrite existing files without force
if (( ! _optstdout )) && [[ -f $_optgenimg ]]; then
	(( _optforce )) || die 'cannot write image: file exists'
fi

COMPRESSION="$(type -P ${COMPRESSION[@]} | head -n1)"
COMPRESSION="${COMPRESSION##*/}"

_optcompress=${_optcompress:-${COMPRESSION:-gzip}}
if ! type -P "$_optcompress" > /dev/null; then
	warning 'no such compressor: %s' "$_optcompress"
	_optcompress=cat
fi

msg "$KERNELVERSION, $_optcompress${_optrootfs:+, sysroot:$_optrootfs}"

# set functrace and trap to catch errors in add_* functions
declare -i _builderrors=0
set -o functrace
trap '(( $? )) && [[ $FUNCNAME = add_* ]] && (( ++_builderrors ))' RETURN

# prime the _addedmodules list with the builtins for this kernel
if [[ -r $_d_kmoduledir/modules.builtin ]]; then
	while IFS=/ read -a path; do
		modname=${path[-1]%.ko}
		_addedmodules["${modname//-/_}"]=2
	done <"$_d_kmoduledir/modules.builtin"
	unset modname path
fi

_binaries="$_d_workdir/binaries"

map run_build_hook "${_hooks[@]}" || (( ++_builderrors ))
(( ${#_fwerrors[@]} )) && warning 'possibly missing firmware: %s' "${_fwerrors[*]}"

add 'mr - ^usr/sbin/ usr/bin/'
[[ -f "$_binaries" ]] && sort -u "$_binaries" | add

load_config "$_f_config"
add 'mc -'

# switch out the error handler to catch all errors
trap -- RETURN
trap '(( ++_builderrors ))' ERR
set -o errtrace

install_modules "${!_modpaths[@]}"

# unset errtrace and trap
set +o functrace
set +o errtrace
trap -- ERR

ARCHIVEGEN_OPTIONS+=("${_optvars[@]}")

if (( _optarchive )); then
	archivegen -rootfs "$_optrootfs" -print -elf.{expand,fallback} \
		"${ARCHIVEGEN_OPTIONS[@]}" "$BUILDARCHIVE" "$@"
elif (( ! _optnogen )); then
	build_image "$_optgenimg" "$_optcompress" "$@"
fi

cleanup $(( !!_builderrors ))
